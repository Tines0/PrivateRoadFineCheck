<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin"/>
  <meta http-equiv="Cross-Origin-Embedder-Policy" content="require-corp"/>
  <title>Roadside Privacy Â· Zama FHE</title>
  <style>
    :root{
      --bg:#fbfcfe;--ink:#0f172a;--muted:#64748b;--panel:#ffffff;--line:#e5e7eb;
      --accent:#2563eb;--radius:16px;--shadow:0 12px 30px rgba(15,23,42,.08);
      --mono: ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
      --sans: Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica Neue,Arial,sans-serif;
    }
    *{box-sizing:border-box}
    body{margin:0;background:radial-gradient(80vw 80vw at 100% -10%, #e7f3ff 0%, transparent 50%),var(--bg);color:var(--ink);font-family:var(--sans);line-height:1.4}
    .wrap{max-width:1100px;margin:28px auto;padding:0 16px}
    h1{margin:0 0 4px;font-size:28px;letter-spacing:-.02em}
    .sub{color:var(--muted);margin-bottom:18px}
    header{display:flex;align-items:center;gap:16px;flex-wrap:wrap;justify-content:space-between}
    .addr{font:600 12px var(--mono);color:var(--muted);border:1px dashed var(--line);padding:6px 10px;border-radius:999px;background:#fff}
    .btn{appearance:none;border:1px solid var(--line);background:#fff;color:#111827;border-radius:999px;padding:10px 14px;font-weight:700;cursor:pointer;transition:.15s;box-shadow:var(--shadow)}
    .btn:hover{transform:translateY(-1px)}
    .btn[disabled]{opacity:.6;cursor:not-allowed;transform:none}
    .btn.primary{background:linear-gradient(180deg,#3b82f6,#2563eb);border-color:#3b82f6;color:#fff}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:18px;margin-top:18px}
    @media (max-width:980px){.grid{grid-template-columns:1fr}}
    .card{background:var(--panel);border:1px solid var(--line);border-radius:var(--radius);box-shadow:var(--shadow);padding:18px}
    .card h2{margin:0 0 12px;font-size:18px}
    .hint{font-size:12px;color:var(--muted);border:1px dashed var(--line);padding:10px;border-radius:12px;background:#fff;margin-bottom:12px}
    .rows{display:grid;gap:10px}
    .two{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    label{font-size:12px;font-weight:700;color:#374151;text-transform:uppercase;letter-spacing:.05em}
    input{width:100%;padding:12px 14px;border:1px solid var(--line);border-radius:12px;background:#fff;outline:none;font-weight:700}
    input:focus{border-color:#93c5fd;box-shadow:0 0 0 4px rgba(59,130,246,.12)}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .status{margin-top:18px;border:1px solid var(--line);background:#fff;border-radius:12px;padding:14px;min-height:54px;display:flex;align-items:center;justify-content:center;font:600 13px var(--mono);color:#0f172a}
    .status.ok{border-color:#bbf7d0;color:#065f46}
    .status.err{border-color:#fecaca;color:#991b1b}
    .bar{height:10px;border-radius:999px;background:repeating-linear-gradient(90deg,#111827 0 18px,#fbbf24 18px 36px);box-shadow:inset 0 0 0 1px var(--line)}
    .badge{display:inline-flex;align-items:center;gap:8px;padding:8px 10px;border:1px dashed var(--line);border-radius:12px;background:#fff;font:700 12px var(--mono);color:var(--muted)}
    .sep{height:1px;background:var(--line);margin:12px 0}
    small.mono{font:600 11px var(--mono);color:var(--muted)}
  </style>
</head>
<body>
  <main class="wrap">
    <header>
      <div>
        <h1>Roadside privacy, <span style="color:#2563eb">enforced</span>.</h1>
        <div class="sub">Compare encrypted speed vs encrypted limit. Only the verdict is revealed to the officer.</div>
      </div>
      <div class="row">
        <span id="officerTag" class="addr">Officer: â€”</span>
        <button id="btnConnect" class="btn primary">Connect Wallet</button>
      </div>
    </header>

    <section class="grid">
      <article class="card">
        <h2>Roadside Check</h2>
        <div class="hint">Officer enters road id, license plate (hashed on device), and measured speed (km/h). Decryption is private (user-decrypt).</div>
        <div class="rows">
          <div class="two">
            <div>
              <label for="roadId">Road ID</label>
              <input id="roadId" type="number" min="1" placeholder="1" />
            </div>
            <div>
              <label for="speed">Speed (km/h)</label>
              <input id="speed" type="number" min="0" placeholder="80" />
            </div>
          </div>
          <div class="two">
            <div>
              <label for="plate">License Plate</label>
              <input id="plate" type="text" placeholder="AA345" />
            </div>
            <div>
              <label for="salt">Salt (secret)</label>
              <input id="salt" type="text" placeholder="random string" />
            </div>
          </div>
          <div class="row">
            <button id="btnCheck" class="btn primary">Submit Private Check</button>
            <button id="btnPreview" class="btn">Preview Plate Hash</button>
          </div>
          <small id="platePreview" class="mono">â€”</small>
          <div id="leftStatus" class="status">â€”</div>
        </div>
      </article>

      <article class="card">
        <h2>Road Limits (Admin)</h2>
        <div class="hint">Owner uploads encrypted speed limits per road id. For development you may set a plain limit.</div>
        <div class="rows">
          <div class="two">
            <div>
              <label for="roadIdAdm">Road ID</label>
              <input id="roadIdAdm" type="number" min="1" placeholder="1" />
            </div>
            <div>
              <label for="limit">Limit (km/h)</label>
              <input id="limit" type="number" min="1" placeholder="70" />
            </div>
          </div>
          <div class="row">
            <button id="btnSetEnc" class="btn primary">Set Encrypted Limit</button>
            <button id="btnSetPlain" class="btn">Set Plain Limit (dev)</button>
            <button id="btnClear" class="btn">Clear</button>
          </div>
          <div class="bar"></div>
          <div class="row" style="justify-content:space-between">
            <span class="badge">Contract: <span id="addr" style="font-weight:800;color:#111827"></span></span>
            <span id="readyBadge" class="badge">â€”</span>
          </div>
          <div id="rightStatus" class="status">Ready</div>
        </div>
      </article>
    </section>

    <div class="sep"></div>
    <small class="mono">Powered by Zama FHE â€¢ Relayer SDK 0.2.0 â€¢ Ethers v6</small>
  </main>

  <script type="module" crossorigin src="https://cdn.zama.ai/relayer-sdk-js/0.2.0/relayer-sdk-js.js"></script>
  <script type="module" crossorigin src="https://cdn.jsdelivr.net/npm/ethers@6.15.0/+esm"></script>

  <script type="module">
    import { BrowserProvider, Contract, keccak256, toUtf8Bytes } from "https://cdn.jsdelivr.net/npm/ethers@6.15.0/+esm";
    import { initSDK, createInstance, SepoliaConfig, generateKeypair } from "https://cdn.zama.ai/relayer-sdk-js/0.2.0/relayer-sdk-js.js";

    // ===== Config =====
    const CONTRACT_ADDRESS = "0xC16c6C25dCd9d81f6e657839e23CCa0A0462DcB5";
    const RELAYER_URL = "https://relayer.testnet.zama.cloud";

    const abi = [
      { inputs: [], name: "version", outputs: [{ type: "string" }], stateMutability: "pure", type: "function" },
      { inputs: [], name: "owner", outputs: [{ type: "address" }], stateMutability: "view", type: "function" },
      { inputs: [{ name: "newOwner", type: "address" }], name: "transferOwnership", outputs: [], stateMutability: "nonpayable", type: "function" },
      { inputs: [{ name: "roadId", type: "uint256" }], name: "hasLimit", outputs: [{ type: "bool" }], stateMutability: "view", type: "function" },
      { inputs: [{ name: "roadId", type: "uint256" }], name: "getPlain", outputs: [{ type: "bool" }, { type: "bool" }, { type: "uint16" }], stateMutability: "view", type: "function" },
      { inputs: [{ name: "roadId", type: "uint256" }], name: "getEncryptedHandle", outputs: [{ type: "bytes32" }], stateMutability: "view", type: "function" },
      { inputs: [{ name: "roadId", type: "uint256" }, { name: "limitExt", type: "bytes32" }, { name: "proof", type: "bytes" }], name: "setLimit", outputs: [], stateMutability: "nonpayable", type: "function" },
      { inputs: [{ name: "roadId", type: "uint256" }, { name: "limit", type: "uint16" }], name: "setLimitPlain", outputs: [], stateMutability: "nonpayable", type: "function" },
      { inputs: [{ name: "roadId", type: "uint256" }], name: "clearLimit", outputs: [], stateMutability: "nonpayable", type: "function" },
      { inputs: [{ name: "roadId", type: "uint256" }, { name: "plateHash", type: "bytes32" }, { name: "speedExt", type: "bytes32" }, { name: "proof", type: "bytes" }], name: "checkVehicle", outputs: [{ type: "bytes32" }], stateMutability: "nonpayable", type: "function" },
      { inputs: [{ name: "valueExt", type: "bytes32" }, { name: "proof", type: "bytes" }], name: "selfTestProof", outputs: [{ type: "bytes32" }], stateMutability: "nonpayable", type: "function" },
      { anonymous:false, inputs:[{ indexed:true, name:"officer", type:"address" },{ indexed:true, name:"roadId", type:"uint256" },{ indexed:false, name:"plateHash", type:"bytes32" },{ indexed:false, name:"verdictHandle", type:"bytes32" }], name:"VehicleChecked", type:"event" },
      { anonymous:false, inputs:[{ indexed:true, name:"roadId", type:"uint256" },{ indexed:false, name:"encrypted", type:"bool" },{ indexed:false, name:"plainValueIfAny", type:"uint16" }], name:"RoadLimitSet", type:"event" },
      { anonymous:false, inputs:[{ indexed:true, name:"roadId", type:"uint256" }], name:"RoadLimitCleared", type:"event" },
    ];

    // ===== UI =====
    const $ = (id) => document.getElementById(id);
    const els = {
      btnConnect: $("btnConnect"),
      officerTag: $("officerTag"),
      addr: $("addr"),
      readyBadge: $("readyBadge"),
      roadId: $("roadId"),
      speed: $("speed"),
      plate: $("plate"),
      salt: $("salt"),
      platePreview: $("platePreview"),
      btnPreview: $("btnPreview"),
      btnCheck: $("btnCheck"),
      leftStatus: $("leftStatus"),
      roadIdAdm: $("roadIdAdm"),
      limit: $("limit"),
      btnSetEnc: $("btnSetEnc"),
      btnSetPlain: $("btnSetPlain"),
      btnClear: $("btnClear"),
      rightStatus: $("rightStatus"),
    };
    els.addr.textContent = CONTRACT_ADDRESS;

    // ===== Logging helpers (ÐºÐ°Ðº Ð² Ñ‚Ð²Ð¾Ñ‘Ð¼ Ð¿Ñ€Ð¸Ð¼ÐµÑ€Ðµ) =====
    const stamp = () => new Date().toISOString().replace('T',' ').replace('Z','');
    const DLOG = {
      info:(s,...a)=>console.log(`%c[APP ${stamp()}]`, 'color:#334155', s, ...a),
      ok:(s,...a)=>console.log(`%c[APP ${stamp()}]`, 'color:#059669', s, ...a),
      warn:(s,...a)=>console.log(`%c[APP ${stamp()}]`, 'color:#b45309', s, ...a),
      err:(s,...a)=>console.error(`%c[APP ${stamp()}]`, 'color:#b91c1c', s, ...a),
      group:(title)=>console.groupCollapsed(`%c${title}`, 'color:#2563eb'),
      end:()=>console.groupEnd(),
    };
    const kb = n => (n/1024).toFixed(2)+' KB';
    const prev = (s, n=10) => (s = String(s), s.length>2*n ? s.slice(0,n)+'â€¦'+s.slice(-n) : s);

    const FHELOG = {
      encStart(meta){ DLOG.group('[FHE] encrypt â†’ createInput'); console.log('meta:', meta); },
      encAdd(tag,val){ console.log('add:', tag, val); },
      encDone(handles, proofBytes){ console.log('handles:', handles, 'proof(bytes):', proofBytes, 'size:', kb(proofBytes)); DLOG.end(); },
      staticOk(){ DLOG.ok('[FHE] staticCall OK'); },
      txSent(hash){ DLOG.info('[TX] sent', hash); },
      txMined(rcpt){ DLOG.ok('[TX] mined', { blockNumber: rcpt.blockNumber, gasUsed: String(rcpt.gasUsed||'') }); },
      eventParsed(name, obj){ DLOG.info('[EVT] '+name, obj); },
      userDecStart(meta){ DLOG.group('[FHE] userDecrypt'); console.log('meta:', meta); },
      userDecSig(sig){ console.log('sig:', prev(sig, 16)); },
      userDecDone(out){ console.log('result:', out); DLOG.end(); },
    };

    // ===== Helpers =====
    function short(a){ return a ? a.slice(0,6)+"â€¦"+a.slice(-4) : "â€”"; }
    function setStatus(el, text, ok=null){
      el.textContent = text;
      el.className = "status"+(ok===true?" ok": ok===false?" err": "");
    }
    const asBig = (x)=>{ try{ return BigInt(x); }catch{ return 0n; } };
    function plateHash(plate, salt){ return keccak256(toUtf8Bytes((plate||"").trim()+"|"+(salt||"").trim())); }

    // ===== State =====
    let provider, signer, user, contract, relayer, isOwner=false;

    // ===== Connect =====
    els.btnConnect.onclick = async () => {
      try{
        DLOG.group('Connect flow');
        if(!window.ethereum) throw new Error("MetaMask not found");
        provider = new BrowserProvider(window.ethereum);
        await provider.send("eth_requestAccounts", []);
        const net = await provider.getNetwork();
        DLOG.info('Network:', String(net.chainId));
        if (net.chainId !== 11155111n){
          DLOG.warn('Switching to Sepolia...');
          await provider.send("wallet_switchEthereumChain", [{ chainId: "0xaa36a7" }]);
        }
        signer = await provider.getSigner();
        user = await signer.getAddress();
        contract = new Contract(CONTRACT_ADDRESS, abi, signer);
        els.btnConnect.disabled = true; els.btnConnect.textContent = short(user);
        els.officerTag.textContent = "Officer: " + short(user);
        DLOG.ok('Connected as', user);

        setStatus(els.rightStatus, "Bootstrapping Relayerâ€¦");
        await initSDK();
        relayer = await createInstance({ ...SepoliaConfig, relayerUrl: RELAYER_URL, network: window.ethereum, debug: true });
        els.readyBadge.textContent = "Relayer ready âœ“";
        DLOG.ok('Relayer ready', RELAYER_URL);

        try{ const o = await contract.owner(); isOwner = (o.toLowerCase() === user.toLowerCase()); DLOG.info('Owner:', o); }catch{}
        els.btnSetEnc.disabled = !isOwner; els.btnSetPlain.disabled = !isOwner; els.btnClear.disabled = !isOwner;

        setStatus(els.rightStatus, "Ready");
      }catch(e){
        DLOG.err('Connect error', e);
        setStatus(els.rightStatus, e.message || String(e), false);
      } finally { DLOG.end(); }
    };

    // ===== Preview plate hash =====
    els.btnPreview.onclick = () => {
      const h = plateHash(els.plate.value, els.salt.value);
      els.platePreview.textContent = h;
      DLOG.info('Plate hash =', h);
    };

    // ===== Admin: set encrypted limit =====
    els.btnSetEnc.onclick = async () => {
      try{
        const roadId = BigInt(els.roadIdAdm.value || "0");
        const limit = Number(els.limit.value || "0");
        if (roadId<=0n) throw new Error("Enter valid road id");
        if (!Number.isFinite(limit) || limit<=0 || limit>65535) throw new Error("Enter limit 1..65535");

        setStatus(els.rightStatus, "Encrypting limitâ€¦");
        FHELOG.encStart({ contract: CONTRACT_ADDRESS, roadId: String(roadId) });
        const buf = relayer.createEncryptedInput(CONTRACT_ADDRESS, user);
        FHELOG.encAdd('add16(limit)', limit);
        buf.add16(limit);
        const { handles, inputProof } = await buf.encrypt();
        FHELOG.encDone(handles, inputProof?.length ?? 0);

        setStatus(els.rightStatus, "Submittingâ€¦");
        await contract.setLimit.staticCall(roadId, handles[0], inputProof);
        FHELOG.staticOk();

        const tx = await contract.setLimit(roadId, handles[0], inputProof);
        FHELOG.txSent(tx.hash);
        const rcpt = await tx.wait();
        FHELOG.txMined(rcpt);

        setStatus(els.rightStatus, "Encrypted limit set âœ“", true);
      }catch(e){
        DLOG.err('setEnc error', e);
        setStatus(els.rightStatus, e.message || String(e), false);
      }
    };

    // ===== Admin: plain limit =====
    els.btnSetPlain.onclick = async () => {
      try{
        const roadId = BigInt(els.roadIdAdm.value || "0");
        const limit = BigInt(els.limit.value || "0");
        if (roadId<=0n) throw new Error("Enter valid road id");
        if (limit<=0n || limit>65535n) throw new Error("Enter limit 1..65535");
        setStatus(els.rightStatus, "Submitting plainâ€¦");
        const tx = await contract.setLimitPlain(roadId, limit);
        FHELOG.txSent(tx.hash);
        const rcpt = await tx.wait();
        FHELOG.txMined(rcpt);
        setStatus(els.rightStatus, "Plain limit set âœ“", true);
      }catch(e){
        DLOG.err('setPlain error', e);
        setStatus(els.rightStatus, e.message || String(e), false);
      }
    };

    // ===== Admin: clear =====
    els.btnClear.onclick = async () => {
      try{
        const roadId = BigInt(els.roadIdAdm.value || "0");
        if (roadId<=0n) throw new Error("Enter valid road id");
        setStatus(els.rightStatus, "Clearingâ€¦");
        const tx = await contract.clearLimit(roadId);
        FHELOG.txSent(tx.hash);
        const rcpt = await tx.wait();
        FHELOG.txMined(rcpt);
        setStatus(els.rightStatus, "Cleared âœ“", true);
      }catch(e){
        DLOG.err('clear error', e);
        setStatus(els.rightStatus, e.message || String(e), false);
      }
    };

    // ===== Roadside check (private) =====
    els.btnCheck.onclick = async () => {
      try{
        if (!relayer || !contract) throw new Error("Connect wallet first");
        const roadId = BigInt(els.roadId.value || "0");
        const sp = Number(els.speed.value || "0");
        const plate = (els.plate.value||"").trim();
        const salt = (els.salt.value||"").trim();
        if (roadId<=0n) throw new Error("Enter valid road id");
        if (!Number.isFinite(sp) || sp<0 || sp>65535) throw new Error("Enter speed 0..65535");
        if (!plate) throw new Error("Enter license plate");
        if (!salt) throw new Error("Enter salt");

        const ph = plateHash(plate, salt);
        DLOG.info('plateHash', ph);

        setStatus(els.leftStatus, "Encrypting speedâ€¦");
        FHELOG.encStart({ contract: CONTRACT_ADDRESS, roadId: String(roadId), plateHash: ph });
        const buf = relayer.createEncryptedInput(CONTRACT_ADDRESS, user);
        FHELOG.encAdd('add16(speed)', sp);
        buf.add16(sp);
        const { handles, inputProof } = await buf.encrypt();
        FHELOG.encDone(handles, inputProof?.length ?? 0);

        setStatus(els.leftStatus, "Submittingâ€¦");
        await contract.checkVehicle.staticCall(roadId, ph, handles[0], inputProof);
        FHELOG.staticOk();

        const tx = await contract.checkVehicle(roadId, ph, handles[0], inputProof);
        FHELOG.txSent(tx.hash);
        const rcpt = await tx.wait();
        FHELOG.txMined(rcpt);

        // Parse VehicleChecked
        const topic = contract.interface.getEvent("VehicleChecked").topicHash;
        const log = rcpt.logs.find(l => l.topics?.[0] === topic);
        if (!log) throw new Error("Event not found");
        const parsed = contract.interface.parseLog(log);
        const verdictH = parsed.args.verdictHandle;
        FHELOG.eventParsed('VehicleChecked', { officer: parsed.args.officer, roadId: String(parsed.args.roadId), verdictHandle: verdictH });

        setStatus(els.leftStatus, "Decrypting verdictâ€¦");
        // userDecrypt
        const kp = await generateKeypair();
        const startTs = Math.floor(Date.now()/1000).toString();
        const days = "7";
        const eip = relayer.createEIP712(kp.publicKey, [CONTRACT_ADDRESS], startTs, days);
        const sig = await signer.signTypedData(
          eip.domain,
          { UserDecryptRequestVerification: eip.types.UserDecryptRequestVerification },
          eip.message
        );
        FHELOG.userDecStart({ handle: verdictH, startTs, days });
        FHELOG.userDecSig(sig);

        const pairs = [{ handle: verdictH, contractAddress: CONTRACT_ADDRESS }];
        const out = await relayer.userDecrypt(pairs, kp.privateKey, kp.publicKey, sig.replace("0x",""), [CONTRACT_ADDRESS], user, startTs, days);
        FHELOG.userDecDone(Object.keys(out));

        let v = out[verdictH];
        if (v===undefined){
          const k = Object.keys(out).find(k=>k.toLowerCase()===verdictH.toLowerCase());
          v = k ? out[k] : undefined;
        }
        const verdict = asBig(v);

        if (verdict === 1n){
          setStatus(els.leftStatus, "ðŸš¨ Verdict: FINE (speed > limit)", false);
        } else if (verdict === 0n){
          setStatus(els.leftStatus, "âœ… Verdict: OK (within limit)", true);
        } else {
          setStatus(els.leftStatus, "Unexpected verdict: "+String(verdict), false);
        }
      }catch(e){
        DLOG.err('check error', e);
        setStatus(els.leftStatus, e.message || String(e), false);
      }
    };
  </script>
</body>
</html>
